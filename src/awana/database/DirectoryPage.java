package awana.database;

import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.image.ImageObserver;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Vector;
import javax.swing.DefaultListModel;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.ListModel;

/**
 *
 * @author Renlar
 */
public class DirectoryPage extends javax.swing.JFrame {

	private ArrayList<JComponent> tabs;
	private Vector<Listing> records;
	private Vector<Listing> displayList;
	private DatabaseWrapper databaseWrapper;
	private Record selectedRecord;

	/**
	 * Creates new form DirectoryPage
	 */
	public DirectoryPage() {
		initComponents();
		Record.loadMasterFields(); //do not remove temporary record load fix will be replaced with dynamic loading once variable yml field loading is supproted
		databaseWrapper = new DatabaseWrapper();
		loadSortAndDisplayRecordNames();
		tabs = new ArrayList<>();
	}

	/**
	 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
	 * content of this method is always regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        recordData = new javax.swing.JTabbedPane();
        recordScrollPane = new javax.swing.JScrollPane();
        recordItemList = new javax.swing.JList();
        newRecord = new javax.swing.JButton();
        deleteRecord = new javax.swing.JButton();
        searchBox = new javax.swing.JTextField();
        menuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        recordScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        recordScrollPane.setName(""); // NOI18N

        recordItemList.setModel(getListItems());
        recordItemList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        recordItemList.setName(""); // NOI18N
        recordItemList.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                listingSelected(evt);
            }
        });
        recordScrollPane.setViewportView(recordItemList);

        newRecord.setText("New");
        newRecord.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                newRecordHandler(evt);
            }
        });

        deleteRecord.setText("Delete");
        deleteRecord.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                deleteRecordHandler(evt);
            }
        });

        searchBox.setForeground(new java.awt.Color(150, 150, 150));
        searchBox.setText("Search");
        searchBox.setName(""); // NOI18N
        searchBox.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                searchBoxFocusGainedHandler(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                searchBoxFocusLostHandler(evt);
            }
        });
        searchBox.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                searchBoxKeyTypedHandler(evt);
            }
        });

        fileMenu.setText("File");
        menuBar.add(fileMenu);

        setJMenuBar(menuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(newRecord, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(deleteRecord, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(searchBox, javax.swing.GroupLayout.PREFERRED_SIZE, 200, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(recordScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 200, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(recordData, javax.swing.GroupLayout.DEFAULT_SIZE, 570, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(recordData)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(searchBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(recordScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 352, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(newRecord)
                            .addComponent(deleteRecord))))
                .addContainerGap())
        );

        recordScrollPane.getAccessibleContext().setAccessibleName("");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void newRecordHandler(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_newRecordHandler
		newRecord();
    }//GEN-LAST:event_newRecordHandler

    private void deleteRecordHandler(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_deleteRecordHandler
		String msgNoRecordSelected = "No Record Selected.";
		Listing delete = getSelectedListing();
		if (delete == null) {
			JOptionPane.showMessageDialog(this, msgNoRecordSelected,
					"Null",
					JOptionPane.YES_NO_OPTION);
			return;
		}
		String[] confirmDeleteOptions = {"Delete", "Cancel"};
		String msgConfirmDelete = "<html>Are You sure you want to delete,</html>\n<html>"
				+ delete.getFullNameLastFirst()
				+ "</html>.\n<html><b>This can not be undone.</b></html>";
		int choice = JOptionPane.showOptionDialog(this, msgConfirmDelete,
				"Confirm Delete",
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE,
				null,
				confirmDeleteOptions,
				confirmDeleteOptions[1]);
		if (choice == JOptionPane.YES_OPTION) {
			databaseWrapper.deleteListing(delete);
			removeAndUpdateListing(delete);
		}
    }//GEN-LAST:event_deleteRecordHandler

    private void searchBoxFocusGainedHandler(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_searchBoxFocusGainedHandler
		searchBox.setForeground(java.awt.Color.BLACK);
		searchBox.setText("");
    }//GEN-LAST:event_searchBoxFocusGainedHandler

    private void searchBoxKeyTypedHandler(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_searchBoxKeyTypedHandler

		char pressed = evt.getKeyChar();
		if (pressed == '\b' || pressed == (char) 127) {
			displayList = searchRecords(records, searchBox.getText());
		} else {
			displayList = searchRecords(displayList, searchBox.getText());
		}
		updateRecordDisplay();

    }//GEN-LAST:event_searchBoxKeyTypedHandler

    private void searchBoxFocusLostHandler(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_searchBoxFocusLostHandler
		searchBox.setForeground(Color.GRAY);
		searchBox.setText("Search");
    }//GEN-LAST:event_searchBoxFocusLostHandler

    private void listingSelected(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_listingSelected
		if (recordItemList.getSelectedValue() != null) {
			selectedRecord = databaseWrapper.getRecord(((Listing) recordItemList.getSelectedValue()).getID());
			loadRecordData();
		} else {
			selectedRecord = null;
			clearRecordData();
		}
    }//GEN-LAST:event_listingSelected

	public void loadRecordData() {
		tabs = getTabs();
		addTabs(tabs);
	}

	public void clearRecordData() {
		recordData.removeAll();
		recordData.revalidate();
	}

	public void removeAndUpdateListing(Listing r) {
		records.remove(r);
		sortAndDisplayRecordNames();
	}

	public void newRecord() {
		Record s = databaseWrapper.newRecord();
		Listing l = s.createListing();
		addAndDisplayListing(l);
		selectListing(l);
	}

	public void addAndDisplayListing(Listing r) {
		records.add(r);
		sortAndDisplayRecordNames();
	}

	public void loadSortAndDisplayRecordNames() {
		records = databaseWrapper.getRecordListingsAsVector();
		sortAndDisplayRecordNames();
	}

	public void sortAndDisplayRecordNames() {
		SortRecordsAlphabeticlyQuickSort();
		displayList = (Vector<Listing>) records.clone();
		recordItemList.setListData((Vector<Listing>) displayList.clone());
		updateRecordDisplay();
	}

	public void updateRecordDisplay() {
		recordItemList.revalidate();  //TODO: find out which of the following lines are necessary
		recordScrollPane.revalidate();
		recordScrollPane.repaint();
	}

	public void selectListing(Listing l) {
		recordItemList.setSelectedValue(l, true);
	}

	public void addTabs(ArrayList<JComponent> tabs) {
		JComponent tab;
		for (int i = 0; i < tabs.size(); i++) {
			addTab(tabs.get(i));
		}
	}

	public void addTab(JComponent tab) {
		recordData.addTab(tab.getName(), tab);
	}

	public ArrayList<JComponent> getTabs() {
		ArrayList<JComponent> tabList = new ArrayList<>();
		ArrayList<String> bookTabNames = new ArrayList<>();
		JScrollPane scrollPane = new JScrollPane();
		scrollPane.setName("Contact");
		JPanel contactPane = new JPanel();
		contactPane.setName("Contact");
		contactPane.setLayout(new FlowLayout());
		for (int i = 0; i < Record.getFieldListSize(); i++) {
			JLabel label = new JLabel();
			label.setText(Record.getMasterField(i).getName());
			contactPane.add(label);
			JTextField text = new JTextField();
			text.setName(Record.getMasterField(i).getName());
			text.setSize(Record.getMasterField(i).getDisplayLength() * 5, 10);
			contactPane.add(text);
		}
		scrollPane.add(contactPane);
		tabList.add(scrollPane);
		bookTabNames.addAll(Record.getBookGroups());
		for (int i = 0; i < bookTabNames.size(); i++) {
		JScrollPane scrollPane1 = new JScrollPane();
		scrollPane.setName("Contact");
		JPanel jPane = new JPanel();
			jPane.setName(bookTabNames.get(i));
			jPane.setLayout(new FlowLayout());
			ArrayList<String> names = Record.getBookNamesByGroup(bookTabNames.get(i));
			for (int j = 0; j < Record.getMasterBook(i).getNumberOfSections(); j++) {
				Section s = Record.getMasterBook(i).getSection(j);
				JCheckBox box = new JCheckBox();
				box.setText(s.getName());
				jPane.add(box);
				JFormattedTextField date = new JFormattedTextField(new SimpleDateFormat("mm/dd/yyyy"));
				date.setEditable(false);
				if(s.getCompletionDate() != null){
					date.setText(s.getCompletionDate().getMonth() + "//" + s.getCompletionDate().getDate() + "//" + s.getCompletionDate().getYear());
				}
				jPane.add(date);
			}
			scrollPane1.add(jPane);
			tabList.add(scrollPane1);
		}
		return tabList;
	}

	/**
	 * @param args the command line arguments
	 */
	public static void main(String args[]) {
		/* Set the Nimbus look and feel */
		//<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
		 * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
		 */
		try {
			for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
				if ("Nimbus".equals(info.getName())) {
					javax.swing.UIManager.setLookAndFeel(info.getClassName());
					break;
				}
			}
		} catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
			java.util.logging.Logger.getLogger(DirectoryPage.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
		}
		//</editor-fold>

		/* Create and display the form */
		java.awt.EventQueue.invokeLater(new Runnable() {
			public void run() {
				new DirectoryPage().setVisible(true);
			}
		});
	}
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton deleteRecord;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JButton newRecord;
    private javax.swing.JTabbedPane recordData;
    private javax.swing.JList recordItemList;
    private javax.swing.JScrollPane recordScrollPane;
    private javax.swing.JTextField searchBox;
    // End of variables declaration//GEN-END:variables

	private void SortRecordsAlphabeticlyQuickSort() {
		if (!records.isEmpty()) {
			quickSortAlphabeticly(records, 0, records.size() - 1);
		}
	}

	private void quickSortAlphabeticly(Vector<Listing> list, int left, int right) {
		int index = partition(list, left, right);
		if (left < index - 1) {
			quickSortAlphabeticly(list, left, index - 1);
		}
		if (index < right) {
			quickSortAlphabeticly(list, index, right);
		}
	}

	private int partition(Vector<Listing> list, int left, int right) {
		int i = left, j = right;
		Listing tmp1, tmp2;
		Listing pivot = list.get((left + right) / 2);

		while (i <= j) {
			while (list.get(i).compairName(pivot) == -1) {
				i++;
			}
			while (list.get(i).compairName(pivot) == 1) {
				j--;
			}
			if (i <= j) {
				tmp1 = list.get(i);
				tmp2 = list.get(j);
				list.remove(i);
				list.add(i, tmp2);
				list.remove(j);
				list.add(j, tmp1);
				i++;
				j--;
			}
		}

		return i;
	}

	private ListModel getListItems() {
		DefaultListModel list = new DefaultListModel();
		return list;
	}

	private Listing getSelectedListing() {
		return (Listing) recordItemList.getSelectedValue();
	}

	private Vector<Listing> searchRecords(Vector<Listing> searchSet, String text) {
		Vector<Listing> resultSet = new Vector<Listing>();
		if (searchSet.isEmpty()) {
			return resultSet;
		}
		int counter = 0;
		while (counter < searchSet.size()) {
			Listing testee = searchSet.get(counter);
			if (testee.getLastName().contains(text) || testee.getFirstName().contains(text)) {
				resultSet.add(testee);
			}
			counter++;
		}
		return resultSet;
	}
	//TODO: put searching entries and loading data in seperate threads from application to eliminate temperary locking of application.

	private void deleteRecord(Listing delete) {
		throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
	}
}